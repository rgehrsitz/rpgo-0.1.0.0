<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FERS Retirement Planning Analysis</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
<style>
body { font-family: Arial, sans-serif; margin:0; padding:20px; background:#f8f9fa; }
header { background:#2c3e50; color:#fff; padding:20px; border-radius:8px; }
section { background:#fff; padding:16px 20px; margin:20px 0; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,.08); }
h1 { margin:0 0 4px 0; font-weight:400; }
.table { width:100%; border-collapse:collapse; }
.table th, .table td { padding:6px 8px; text-align:right; }
.table th:first-child, .table td:first-child { text-align:left; }
.table thead { background:#e5eef5; }
.badge { display:inline-block; background:#3498db; color:#fff; padding:2px 6px; border-radius:4px; font-size:12px; }
.chart-container { position: relative; height: 650px; margin: 20px 0; }
.chart-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
@media (max-width: 768px) {
  .chart-grid { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<header>
  <h1>FERS Retirement Planning Analysis</h1>
  <div class="subtitle">Scenarios Evaluated: {{len .Scenarios}}</div>
</header>
{{if .Assumptions}}
<section>
  <h2>Key Assumptions</h2>
  <ul>
  {{range .Assumptions}}
    <li>{{.}}</li>
  {{end}}
  </ul>
</section>
{{end}}
<section>
  <h2>Scenario Summary</h2>
  <table class="table">
    <thead><tr><th>Scenario</th><th>First Year Net</th><th>Year 5</th><th>Year 10</th><th>Total Lifetime Income</th><th>Success Rate</th><th>TSP Longevity</th><th>Final TSP Balance</th></tr></thead>
    <tbody>
      {{range .Scenarios}}
      <tr>
        <td>{{.Name}}</td>
        <td>{{curr .FirstYearNetIncome}}</td>
        <td>{{curr .Year5NetIncome}}</td>
        <td>{{curr .Year10NetIncome}}</td>
        <td>{{curr .TotalLifetimeIncome}}</td>
        <td>{{pct .SuccessRate}}</td>
        <td>{{.TSPLongevity}}</td>
        <td>{{curr .FinalTSPBalance}}</td>
      </tr>
      {{end}}
    </tbody>
  </table>
</section>
<section>
  <h2>Calendar Year Comparison (Apples-to-Apples)</h2>
  <table class="table">
    <thead><tr><th>Scenario</th><th>2030 Net Income</th><th>2035 Net Income</th><th>2040 Net Income</th></tr></thead>
    <tbody>
      <tr style="background-color: #f8f9fa; font-weight: bold;">
        <td>Pre-Retirement Baseline (with COLA growth)</td>
        <td>{{curr (index .Scenarios 0).PreRetirementNet2030}}</td>
        <td>{{curr (index .Scenarios 0).PreRetirementNet2035}}</td>
        <td>{{curr (index .Scenarios 0).PreRetirementNet2040}}</td>
      </tr>
      {{range .Scenarios}}
      <tr>
        <td>{{.Name}}</td>
        <td>{{curr .NetIncome2030}}</td>
        <td>{{curr .NetIncome2035}}</td>
        <td>{{curr .NetIncome2040}}</td>
      </tr>
      {{end}}
    </tbody>
  </table>
  <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
    <strong>Note:</strong> This table shows net income for specific calendar years across all scenarios, enabling direct comparison. 
    The baseline shows what your current income would be in those years with COLA (cost-of-living) adjustments.
  </p>
</section>

<section>
  <h2>Visual Analysis</h2>
  <div class="chart-grid">
    <div>
      <h3>TSP Balance Over Time</h3>
      <div class="chart-container">
        <canvas id="tspChart"></canvas>
      </div>
    </div>
    <div>
      <h3>Net Income Comparison</h3>
      <div class="chart-container">
        <canvas id="incomeChart"></canvas>
      </div>
    </div>
  </div>
  
    <!-- Cumulative Net Income Comparison (full-width) -->
    <div style="margin-top: 8px;">
      <h3>Cumulative Net Income Comparison</h3>
      <div class="chart-container">
        <canvas id="cumulativeChart"></canvas>
      </div>
    </div>
  
  <div class="chart-grid">
    <div>
      <h3>Income Sources Over Time - Scenario 1</h3>
      <div class="chart-container">
        <canvas id="incomeSourcesChart1"></canvas>
      </div>
    </div>
    {{if gt (len .Scenarios) 1}}
    <div>
      <h3>Income Sources Over Time - Scenario 2</h3>
      <div class="chart-container">
        <canvas id="incomeSourcesChart2"></canvas>
      </div>
    </div>
    {{end}}
  </div>
  
  {{if gt (len .Scenarios) 2}}
  <div class="chart-grid">
    {{range $index, $scenario := slice .Scenarios 2}}
    <div>
      <h3>Income Sources Over Time - Scenario {{add $index 3}}</h3>
      <div class="chart-container">
        <canvas id="incomeSourcesChart{{add $index 3}}"></canvas>
      </div>
    </div>
    {{end}}
  </div>
  {{end}}
</section>
<section>
  <h2>Recommendation</h2>
  {{with $.Recommendation}}
    {{if .ScenarioName}}
      <p>Best Scenario: <strong>{{.ScenarioName}}</strong> <span class="badge">Δ {{curr .NetIncomeChange}} ({{pct .PercentageChange}})</span></p>
    {{else}}
      <p>No recommendation available.</p>
    {{end}}
  {{end}}
</section>

<script>
// Chart data extracted from scenarios
const scenarioData = [
{{- range $scenarioIndex, $scenario := .Scenarios}}
  {
    name: {{$scenario.Name | printf "%q"}},
    years: [{{range $scenario.Projection}}{{.Date.Year}},{{end}}],
  tspBalances: [{{range $scenario.Projection}}{{printf "%.0f" (.TSPBalancePersonA.Add .TSPBalancePersonB).InexactFloat64}},{{end}}],
    netIncomes: [{{range $scenario.Projection}}{{printf "%.0f" .NetIncome.InexactFloat64}},{{end}}],
  salaries: [{{range $scenario.Projection}}{{printf "%.0f" (.SalaryPersonA.Add .SalaryPersonB).InexactFloat64}},{{end}}],
  pensions: [{{range $scenario.Projection}}{{printf "%.0f" (.PensionPersonA.Add .PensionPersonB).InexactFloat64}},{{end}}],
  tspWithdrawals: [{{range $scenario.Projection}}{{printf "%.0f" (.TSPWithdrawalPersonA.Add .TSPWithdrawalPersonB).InexactFloat64}},{{end}}],
  socialSecurity: [{{range $scenario.Projection}}{{printf "%.0f" (.SSBenefitPersonA.Add .SSBenefitPersonB).InexactFloat64}},{{end}}]
  }{{if ne $scenarioIndex (len $.Scenarios | minus1)}},{{end}}
{{- end}}
];

// Server-side computed break-even (if available)
const serverBreakEven = {{if .BreakEven}}{{json .BreakEven}}{{else}}null{{end}};

const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6'];
const sourceColors = {
  salary: '#3498db',
  pension: '#2ecc71', 
  tspWithdrawal: '#f39c12',
  socialSecurity: '#9b59b6'
};

// Helper: convert a fractional calendar year into a month/year string
function monthYearFromFraction(calendarYear, fraction) {
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const year = Math.floor(calendarYear);
  const frac = (typeof fraction === 'number') ? fraction : (calendarYear - year);
  let monthIndex = Math.floor(Math.max(0, Math.min(1, frac)) * 12);
  if (monthIndex >= 12) { monthIndex = 11; }
  return months[monthIndex] + ' ' + year;
}

// Helper: round a dollar amount to the nearest thousand and format with commas
function roundToThousands(n) {
  const rounded = Math.round(n / 1000) * 1000;
  return '$' + rounded.toLocaleString();
}

// TSP Balance Chart - Fixed x-axis scaling
const tspCtx = document.getElementById('tspChart').getContext('2d');
new Chart(tspCtx, {
  type: 'line',
  data: {
    datasets: scenarioData.map((scenario, index) => ({
      label: scenario.name,
      data: scenario.years.map((year, i) => ({ x: parseInt(year), y: parseFloat(scenario.tspBalances[i]) })),
      borderColor: colors[index % colors.length],
      backgroundColor: colors[index % colors.length] + '20',
      fill: false,
      tension: 0.1
    }))
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      title: { display: true, text: 'TSP Balance Over Time' }
    },
    scales: {
      x: { 
        type: 'linear',
        position: 'bottom',
        title: { display: true, text: 'Year' },
        min: Math.min(...scenarioData.flatMap(s => s.years)) - 1,
        max: Math.max(...scenarioData.flatMap(s => s.years)) + 1,
        ticks: {
          stepSize: 5,
          callback: value => Math.round(value)
        }
      },
      y: { 
        title: { display: true, text: 'TSP Balance ($)' },
        ticks: { callback: value => '$' + Math.round(value).toLocaleString() }
      }
    }
  }
});

// Net Income Chart - Fixed x-axis scaling (with optional break-even annotation)
const incomeCtx = document.getElementById('incomeChart').getContext('2d');
const incomeChart = new Chart(incomeCtx, {
  type: 'line',
  data: {
    datasets: scenarioData.map((scenario, index) => ({
      label: scenario.name,
      data: scenario.years.map((year, i) => ({ x: parseInt(year), y: parseFloat(scenario.netIncomes[i]) })),
      borderColor: colors[index % colors.length],
      backgroundColor: colors[index % colors.length] + '20',
      fill: false,
      tension: 0.1
    }))
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      title: { display: true, text: 'Net Income Over Time' }
    },
    scales: {
      x: { 
        type: 'linear',
        position: 'bottom',
        title: { display: true, text: 'Year' },
        min: Math.min(...scenarioData.flatMap(s => s.years)) - 1,
        max: Math.max(...scenarioData.flatMap(s => s.years)) + 1,
        ticks: {
          stepSize: 5,
          callback: value => Math.round(value)
        }
      },
      y: { 
        title: { display: true, text: 'Net Income ($)' },
        ticks: { callback: value => '$' + Math.round(value).toLocaleString() }
      }
    }
  }
});

// If there are at least two scenarios, compute cumulative series and detect first crossover.
if (scenarioData.length >= 2) {
  // If server-side break-even is available, use it directly
  let crossover = null;
  if (serverBreakEven) {
    // serverBreakEven fields: calendar_year, fraction_of_year, cumulative_amount
    crossover = {
      calendarYear: serverBreakEven.calendar_year || serverBreakEven.calendarYear,
      fraction: parseFloat(serverBreakEven.fraction_of_year || serverBreakEven.fraction || 0),
      cumulative: parseFloat(serverBreakEven.cumulative_amount || serverBreakEven.cumulative || 0)
    };
  } else {
    const a = scenarioData[0];
    const b = scenarioData[1];
    const len = Math.min(a.netIncomes.length, b.netIncomes.length, a.years.length, b.years.length);
    let cumA = 0;
    let cumB = 0;

    for (let i = 0; i < len; i++) {
      const yearNetA = parseFloat(a.netIncomes[i] || 0);
      const yearNetB = parseFloat(b.netIncomes[i] || 0);
      const prevDiff = cumA - cumB;
      const prevYear = parseInt(a.years[i]);

      cumA += yearNetA;
      cumB += yearNetB;
      const currDiff = cumA - cumB;

      // Exact equality at year end
      if (Math.abs(currDiff) < 0.01) {
        crossover = {
          calendarYear: prevYear,
          fraction: 1,
          cumulative: cumA
        };
        break;
      }

      // Crossed inside this year if sign changes between prevDiff and currDiff
      if (i > 0 && prevDiff * currDiff < 0) {
        // Interpolate within the year: prevDiff + t*(yearNetA - yearNetB) = 0
        const denom = (yearNetA - yearNetB);
        let t = 0.5;
        if (denom !== 0) {
          t = -prevDiff / denom;
        }
        if (t < 0) t = 0;
        if (t > 1) t = 1;
        const prevCumA = cumA - yearNetA;
        const cumulative = prevCumA + yearNetA * t;
        crossover = {
          calendarYear: parseInt(a.years[i-1]) + t,
          fraction: t,
          cumulative: cumulative
        };
        break;
      }
    }
  }

  // Register a plugin to draw the vertical line and label if we have a crossover
  if (crossover) {
    Chart.register({
      id: 'breakEvenPlugin',
      afterDraw: (chart) => {
        if (!chart.options.scales || !chart.chartArea) return;
        const xScale = chart.scales.x;
        // Allow explicit server-provided month/year when available
        let xValue = crossover.calendarYear;
        let labelText = null;
        if (serverBreakEven && serverBreakEven.break_even_year) {
          const month = serverBreakEven.break_even_month || serverBreakEven.BreakEvenMonth || null;
          const year = serverBreakEven.break_even_year || serverBreakEven.BreakEvenYear || null;
          if (month && year) {
            // compute a fractional calendar year for positioning
            xValue = year + ((month - 1) / 12);
            labelText = (['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][month-1] + ' ' + year);
          }
        }
        const x = xScale.getPixelForValue(xValue);
        const ctx = chart.ctx;
        ctx.save();
        // Draw dashed vertical line
        ctx.beginPath();
        ctx.setLineDash([6, 6]);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.moveTo(x, chart.chartArea.top);
        ctx.lineTo(x, chart.chartArea.bottom);
        ctx.stroke();

  // Draw label box near top: prefer explicit month/year (labelText) otherwise fall back to fractional
  const monthYearLabel = labelText || monthYearFromFraction(crossover.calendarYear, crossover.fraction);
  const label = 'Break-even: ' + monthYearLabel + ' — ' + roundToThousands(crossover.cumulative);
        ctx.setLineDash([]);
        ctx.fillStyle = '#222';
        ctx.font = '12px Arial';
        const textWidth = ctx.measureText(label).width + 8;
        const labelX = Math.min(Math.max(x + 8, chart.chartArea.left + 4), chart.chartArea.right - textWidth - 4);
        const labelY = chart.chartArea.top + 14;
        // background
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(labelX - 4, labelY - 12, textWidth, 18);
        // text
        ctx.fillStyle = '#111';
        ctx.fillText(label, labelX, labelY);
        ctx.restore();
      }
    });

    // Force redraw to show plugin
    incomeChart.update();
  }
}

// Build and render cumulative net income chart (shows cumulative series and delta)
const cumulativeCtxEl = document.getElementById('cumulativeChart');
if (cumulativeCtxEl) {
  // compute cumulative sums per scenario
  const cumulativeData = scenarioData.map(s => {
    let sum = 0;
    return s.netIncomes.map(n => { sum += parseFloat(n || 0); return sum; });
  });

  const cumulativeDatasets = scenarioData.map((s, idx) => ({
    label: s.name + ' (cumulative)',
    data: s.years.map((year, i) => ({ x: parseInt(year), y: cumulativeData[idx][i] || 0 })),
    borderColor: colors[idx % colors.length],
    backgroundColor: colors[idx % colors.length] + '20',
    fill: false,
    tension: 0.1
  }));

  // If there are at least two scenarios, add a delta series (scenario2 - scenario1)
  if (scenarioData.length >= 2) {
    const deltaData = scenarioData[0].years.map((year, i) => {
      const a = cumulativeData[0][i] || 0;
      const b = (cumulativeData[1] && cumulativeData[1][i]) || 0;
      return { x: parseInt(year), y: b - a };
    });
    cumulativeDatasets.push({
      label: 'Delta (Scenario 2 - Scenario 1)',
      data: deltaData,
      borderColor: '#333',
      backgroundColor: 'rgba(50,50,50,0.08)',
      borderDash: [6,4],
      fill: true,
      tension: 0.1
    });
  }

  new Chart(cumulativeCtxEl.getContext('2d'), {
    type: 'line',
    data: { datasets: cumulativeDatasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: { title: { display: true, text: 'Cumulative Net Income Comparison' } },
      scales: {
        x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Year' }, min: Math.min(...scenarioData.flatMap(s => s.years)) - 1, max: Math.max(...scenarioData.flatMap(s => s.years)) + 1, ticks: { stepSize: 5, callback: value => Math.round(value) } },
        y: { title: { display: true, text: 'Cumulative Net Income ($)' }, ticks: { callback: value => '$' + Math.round(value).toLocaleString() } }
      }
    }
  });
}

// Income Sources Over Time Charts - One for each scenario
scenarioData.forEach((scenario, scenarioIndex) => {
  const chartId = `incomeSourcesChart${scenarioIndex + 1}`;
  const ctx = document.getElementById(chartId);
  if (ctx) {
    const yearNumbers = scenario.years.map(year => parseInt(year));
    new Chart(ctx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: 'Salary',
            data: yearNumbers.map((year, i) => ({ x: year, y: parseFloat(scenario.salaries[i]) })),
            backgroundColor: sourceColors.salary + '80',
            borderColor: sourceColors.salary,
            fill: 'origin'
          },
          {
            label: 'FERS Pension',
            data: yearNumbers.map((year, i) => ({ x: year, y: parseFloat(scenario.pensions[i]) })),
            backgroundColor: sourceColors.pension + '80',
            borderColor: sourceColors.pension,
            fill: '-1'
          },
          {
            label: 'TSP Withdrawal',
            data: yearNumbers.map((year, i) => ({ x: year, y: parseFloat(scenario.tspWithdrawals[i]) })),
            backgroundColor: sourceColors.tspWithdrawal + '80', 
            borderColor: sourceColors.tspWithdrawal,
            fill: '-1'
          },
          {
            label: 'Social Security',
            data: yearNumbers.map((year, i) => ({ x: year, y: parseFloat(scenario.socialSecurity[i]) })),
            backgroundColor: sourceColors.socialSecurity + '80',
            borderColor: sourceColors.socialSecurity,
            fill: '-1'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: scenario.name + ' - Income Sources Over Time' }
        },
        scales: {
          x: { 
            type: 'linear',
            position: 'bottom',
            title: { display: true, text: 'Year' },
            min: Math.min(...yearNumbers) - 1,
            max: Math.max(...yearNumbers) + 1,
            ticks: {
              stepSize: 5,
              callback: value => Math.round(value)
            }
          },
          y: { 
            title: { display: true, text: 'Annual Income ($)' },
            stacked: true,
            ticks: { callback: value => '$' + Math.round(value).toLocaleString() }
          }
        },
        interaction: {
          mode: 'index',
          intersect: false
        }
      }
    });
  }
});
</script>
</body>
</html>
